# TLS Configuration. Reduce L1 access time for uniX

depth     = $(issue)
memSizing = $(issue)/4 + 1 #3i,4i,6i -> 1,2,2

NoMigration  = true
tech         = 0.07 # um
procsPerNode = 1
pageSize     = 4096
enableICache = true
issueWrongPath = true

###############################
#  PROCESSORS CONFIGURATION   #
###############################

[issueX]
frequency      = 5e9  # Hz
areaFactor     = ($(issue)*$(depth)+0.1)/16  # Area in relation with alpha264 EV6
inorder        = false
fetchWidth     = ($(issue)/6+1)*6
instQueueSize  = 2*($(issue)/6+1)*6
issueWidth     = $(issue)
retireWidth    = $(issue)
decodeDelay    = 3
renameDelay    = 3
maxBranches    = 4+6*$(depth)
bb4Cycle       = 1
maxIRequests   = 3  # +1 icache hit delay -> 1 outs miss
interClusterLat= 2  # P4 intra +1?
cluster[0]     = 'FXClusterIssueX'
cluster[1]     = 'FPClusterIssueX'
stForwardDelay = 1  # +1 clk from the instruction latency
maxLoads       = 6*$(depth)+30
maxStores      = 4*$(depth)+30
robSize        = 26*$(depth)+48
intRegs        = 48+14*$(depth)
fpRegs         = 32+12*$(depth)
bpred          = 'BPredIssueX'
dataSource     = "DataL1 DL1"
instrSource    = "InstL1 IL1"
dtlb           = 'FXDTLB'
itlb           = 'FXITLB'
OSType         = 'std'
minTLBMissDelay= 16 # Min Clk to services a TLB miss (I/D)

[FXDTLB]
deviceType='tlb'
size =  64*8
assoc = 64
bsize = 8
numPorts = $(memSizing)
replPolicy = 'LRU'

[FXITLB]
deviceType = 'tlb'
size  = 32*8
assoc = 32
bsize = 8
numPorts = 1
replPolicy = 'LRU'

[FXClusterIssueX]
winSize     = 12*$(depth)+32 # window number of entries
recycleAt   = 'Execute'      # Recycle entries at : Execute|Retire
schedNumPorts = 4
schedPortOccp = 1
wakeUpNumPorts= 4
wakeUpPortOccp= 1
wakeupDelay   = 3
schedDelay    = 1 # Minimum latency like a intraClusterLat
iStoreLat   = 1
iStoreUnit  = 'STIssueX'
iLoadLat    = 1
iLoadUnit   = 'LDIssueX'
iALULat     = 1
iALUUnit    = 'ALUIssueX'
iBJLat      = 1
iBJUnit     = 'ALUIssueX'
iDivLat     = 12
iDivUnit    = 'ALUIssueX'
iMultLat    = 4
iMultUnit   = 'ALUIssueX'

[FPClusterIssueX]
winSize     = 8*$(depth)+8      # window number of entries
recycleAt   = 'Execute' # Recycle entries at : Execute|Retire
schedNumPorts = 4
schedPortOccp = 1
wakeUpNumPorts= 4
wakeUpPortOccp= 1
wakeupDelay   = 3
schedDelay    = 1 # Minimum latency like a intraClusterLat
fpALULat    = 2
fpALUUnit   = 'FP0IssueX'
fpMultLat   = 4
fpMultUnit  = 'FP0IssueX'
fpDivLat    = 10
fpDivUnit   = 'FP0IssueX'

[STIssueX]
Num = $(STUnits)
Occ = 1

[LDIssueX]
Num = $(LDUnits)
Occ = 1

[ALUIssueX]
Num = (2*$(issue))/4+1
Occ = 1

[FP0IssueX]
Num = (2*$(issue))/5+1
Occ = 1

# Example of crappy static predictor
[BPredTaken]
type = "Static"
btbSize        = 1
btbBsize       = 1
btbAssoc       = 1
btbReplPolicy  = 'LRU'
btbHistory     = 0
rasSize        = 1

[BPredIssueX]
type           = "hybrid" 
BTACDelay      = 0 # no BTAC
l1size         = 1
l2size         = 16*1024
l2Bits         = 1
historySize    = 11
Metasize       = 16*1024
MetaBits       = 2
localSize      = 16*1024
localBits      = 2
btbSize        = 2048
btbBsize       = 1
btbAssoc       = 2
btbReplPolicy  = 'LRU'
btbHistory     = 0
rasSize        = 0 # 32 is realistic

###############################
[InstL1]
deviceType  =  'icache'
size        =    16*1024
assoc       =        2
bsize       =       64
writePolicy =     'WB'
replPolicy  =    'LRU'
numPorts    =        2
portOccp    =        1
hitDelay    =        2
missDelay   =        0
MSHRsize    =       4
MSHRtype    = 'full'
lowerLevel  =  "SharedL2 L2 shared"


[SharedL2]
deviceType   = 'cache'
size         =1024*1024
assoc        =  8
bsize        = 64
writePolicy  ='WB'
replPolicy   ='LRU'
numPorts     =  1
portOccp     =  1
hitDelay     = 10
missDelay    =  4
MSHRsize     = 32
MSHRtype    = 'full'
lowerLevel  = "$(L2ll)"

[PBuff]
deviceType  = 'prefbuff'
streamCache = 'PBuffStream'
buffCache   = 'PBuffBuff'
depth	    = 1
missWindow  = 16
maxStride   = 512
hitDelay       = 3
missDelay      = 2
learnHitDelay  = 4
learnMissDelay = 6 
lowerLevel  = "AdvMem MemBus shared"

[PBuffStream]
deviceType  = 'cache'
Size        = 16 * 8 
Assoc       = 16
BSize       = 8
ReplPolicy  = 'LRU'
numPorts    = 2
portOccp    = 3

[PBuffBuff]
deviceType  = 'cache'
Size        = 16 * 1024
Assoc       = 4
BSize       = 32
ReplPolicy  = 'LRU'
numPorts    = 2
portOccp    = 3

[AdvMem]
deviceType  =    'bus'
busWidth    =     64
numPorts    =      1
portOccp    =     32   # 5GHz :  64 (L3)/32 = 2 bytes per cycles -> 10GBytes/s
delay       =      1
lowerLevel  =  "BigMem"

[BigMem]
deviceType  = 'niceCache'
size        = 1024
assoc       =    1
bsize       =   64
writePolicy = 'WB'
replPolicy  = 'LRU'
numPorts    =     1
portOccp    =     1
hitDelay    =   490   # 5GHz: ~100ns is 500 cycles (10 L1 + L2 miss)
missDelay   =   1600000 # Not valid
MSHRsize    =   32
MSHRtype    = 'full'
lowerLevel  = "voidDevice"

[voidDevice]
deviceType  =   'void'

##############################
#     BEGIN TASKSCALAR       #
##############################
[TaskScalar]
VersionSize   = 32          # Version size (HVersion) in bits
SyncOnRestart =  3          # Number of restarts before wait to become safe
MLThreshold   = 8*$(nCPUs)  # Merge Last  Threshold Safe thread
MFThreshold   = $(nCPUs)    # Merge First Threshold Safe thread
IDP           = 'IntPred1'  # Interval Predictor
bsize         = 64          # Versioned cache line size

################################
# IDP: Interval Distribution Predictor (one per processor)
[IntPred1]
deviceType   = 'cache' 
IDPnChildMax = 4     # 4 default value, 0 means no prediction
size         = 32*8  # 32 entries
bSize        = 8
Assoc        = 32
ReplPolicy   = 'LRU'
numPorts     = 1
portOccp     = 1
