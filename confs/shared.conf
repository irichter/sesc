# TLS Configuration. Reduce L1 access time for uniX

depth     = $(issue)
memSizing = $(issue)/4 + 1 #3i,4i,6i -> 1,2,2

NoMigration  = true
procsPerNode = 1
pageSize     = 4096
enableICache = true
issueWrongPath = true

technology = 'techParam'

###############################
# clock-panalyzer input       #
###############################
[techParam]
clockTreeStyle = 1		# 1 for Htree or 2 for balHtree
tech       = 70 		# nm
frequency  = 5e9  		# Hz
skewBudget = 20			# in ps
areaOfChip = 200		# in mm^2
loadInClockNode = 20		# in pF
optimalNumberOfBuffer = 3

###############################
# io-panalyzer input          #
###############################
padCapacitance = 1		# in pF
loadCapacitance = 1		# in pF
numberOfioBufferStage = 5	
microstripLength = 10		# in inches

###############################
# logic-panalyzer input       #
###############################
randomLogicStyle = 1		# 1 for Static or 2 for Dynamic
numberOfClusters = 1	
numberofGates = 30000
numberOfFunctions = 4
numberOfFanouts = 1
numberOfFanins = 4

################################
# Temperature Parameters
################################

[ChipSpecs]
chipThickness  = 0.0005    # m
tempThreshold  = 111.8     # C

[HeatSink]
convecC        = 140.4     # J/K
convecR        = 0.1       # K/W
heatsinkSide   = 0.06      # m
heatsinkThick  = 0.069     # m

[HeatSpreader]
spreaderSide   = 0.03      # m
spreaderThick  = 0.001     # m

[InterfaceMaterial]
interfaceThick = 0.000075  # m

[AmbientTemperature]
ambientTemp    = 40        # C
offsetConstant = 273.15    # Kelvin
initialTemp    = 60        # C

################################
# Simulation Parameters
################################

[SimParams]
sampleRate     = 10        # usec
floorPlanFile  = 'scooreX.flp'
hotspotLogFile = 'scooreX.out'
setBinaryLog   = 1
omitLateralR   = 0
dtmUsed        = 0

###############################
#  PROCESSORS CONFIGURATION   #
###############################

[issueX]
archBits       = 32
areaFactor     = ($(issue)*$(depth)+0.1)/16  # Area in relation with alpha264 EV6
inorder        = false
fetchWidth     = ($(issue)/6+1)*6
instQueueSize  = 2*($(issue)/6+1)*6
issueWidth     = $(issue)
retireWidth    = $(issue)
decodeDelay    = 3
renameDelay    = 3
maxBranches    = 4+6*$(depth)
bb4Cycle       = 1
bpredDelay     = 1
maxIRequests   = 3  # +1 icache hit delay -> 1 outs miss
interClusterLat= 2  # P4 intra +1?
cluster[0]     = 'FXClusterIssueX'
cluster[1]     = 'FPClusterIssueX'
stForwardDelay = 1  # +1 clk from the instruction latency
maxLoads       = 6*$(depth)+30
maxStores      = 4*$(depth)+30
LSQBanks       = 1  # Banked LD/ST Queue 
regFileDelay   = 3
robSize        = 26*$(depth)+48
intRegs        = 48+14*$(depth)
fpRegs         = 32+12*$(depth)
bpred          = 'BPredIssueX'
dataSource     = "DataL1 DL1"
instrSource    = "InstL1 IL1"
dtlb           = 'FXDTLB'
itlb           = 'FXITLB'
OSType         = 'std'
minTLBMissDelay= 16 # Min Clk to services a TLB miss (I/D)

[FXDTLB]
deviceType='tlb'
size =  64*8
assoc = 64
bsize = 8
numPorts = $(memSizing)
replPolicy = 'LRU'

[FXITLB]
deviceType = 'tlb'
size  = 32*8
assoc = 32
bsize = 8
numPorts = 1
replPolicy = 'LRU'

[FXClusterIssueX]
winSize      = 12*$(depth)+32 # window number of entries
recycleAt    = 'Execute'      # Recycle entries at : Execute|Retire
schedNumPorts = 4
schedPortOccp = 1
wakeUpNumPorts= 4
wakeUpPortOccp= 1
wakeupDelay   = 3
schedDelay    = 1 # Minimum latency like a intraClusterLat
iStoreLat    = 1
iStoreUnit   = 'STIssueX'
iLoadLat     = 1
iLoadUnit    = 'LDIssueX'
iALULat      = 1
iALUUnit     = 'ALUIssueX'
iBJLat       = 1
iBJUnit      = 'ALUIssueX'
iDivLat      = 12
iDivUnit     = 'ALUIssueX'
iMultLat     = 4
iMultUnit    = 'ALUIssueX'

[FPClusterIssueX]
winSize      = 8*$(depth)+8      # window number of entries
recycleAt    = 'Execute' # Recycle entries at : Execute|Retire
schedNumPorts = 4
schedPortOccp = 1
wakeUpNumPorts= 4
wakeUpPortOccp= 1
wakeupDelay   = 3
schedDelay    = 1 # Minimum latency like a intraClusterLat
fpALULat     = 2
fpALUUnit    = 'FP0IssueX'
fpMultLat    = 4
fpMultUnit   = 'FP0IssueX'
fpDivLat     = 10
fpDivUnit    = 'FP0IssueX'

[STIssueX]
Num = $(STUnits)
Occ = 1

[LDIssueX]
Num = $(LDUnits)
Occ = 1

[ALUIssueX]
Num = (2*$(issue))/4+1
Occ = 1

[FP0IssueX]
Num = (2*$(issue))/5+1
Occ = 1

# Example of crappy static predictor
[BPredTaken]
type = "Static"
btbSize        = 1
btbBsize       = 1
btbAssoc       = 1
btbReplPolicy  = 'LRU'
rasSize        = 1

[BPredIssueX]
type           = "hybrid" 
BTACDelay      = 0 # no BTAC
l1size         = 1
l2size         = 16*1024
l2Bits         = 1
historySize    = 11
Metasize       = 16*1024
MetaBits       = 2
localSize      = 16*1024
localBits      = 2
btbSize        = 2048
btbBsize       = 1
btbAssoc       = 2
btbReplPolicy  = 'LRU'
rasSize        = 0 # 32 is realistic

###############################

[InstL1]
deviceType  =  'icache'
size        =    16*1024
assoc       =        2
bsize       =       64
writePolicy =     'WB'
replPolicy  =    'LRU'
numPorts    =        2
portOccp    =        1
hitDelay    =        2
missDelay   =        0
MSHR        = InstL1MSHR
lowerLevel  =  "L2Cache L2 shared"

[InstL1MSHR]
size = 4
type = 'full'
bsize = 64

[L2Cache]
deviceType   = 'cache'
size         =1024*1024
assoc        =  8
bsize        = 64
writePolicy  ='WB'
replPolicy   ='LRU'
numPorts     =  1
portOccp     =  1
hitDelay     = 10
missDelay    =  4
MSHR         = 'MSHRL2'
lowerLevel  = "$(L2ll)"

[MSHRL2]
type = 'full'
size = 32
bsize = 64

[PBuff]
deviceType  = 'prefbuff'
streamCache = 'PBuffStream'
buffCache   = 'PBuffBuff'
depth	    = 1
missWindow  = 16
maxStride   = 512
hitDelay       = 3
missDelay      = 2
learnHitDelay  = 4
learnMissDelay = 6 
lowerLevel  = "AdvMem MemBus shared"

[PBuffStream]
deviceType  = 'cache'
Size        = 16 * 8 
Assoc       = 16
BSize       = 8
ReplPolicy  = 'LRU'
numPorts    = 2
portOccp    = 3

[PBuffBuff]
deviceType  = 'cache'
Size        = 16 * 1024
Assoc       = 4
BSize       = 32
ReplPolicy  = 'LRU'
numPorts    = 2
portOccp    = 3

[AdvMem]
deviceType  =    'bus'
busWidth    =     64
numPorts    =      1
portOccp    =     32   # 5GHz :  64 (L3)/32 = 2 bytes per cycles -> 10GBytes/s
delay       =      1
lowerLevel  =  "BigMem"

[BigMem]
deviceType  = 'niceCache'
size        = 1024
assoc       =    1
bsize       =   64
writePolicy = 'WB'
replPolicy  = 'LRU'
numPorts    =     1
portOccp    =     1
hitDelay    =   490   # 5GHz: ~100ns is 500 cycles (10 L1 + L2 miss)
missDelay   =   1600000 # Not valid
MSHR        = "BigMemMSHR"
lowerLevel  = "voidDevice"

[BigMemMSHR]
size = 32
type = 'full'
bsize = 64

[voidDevice]
deviceType  =   'void'

##############################
#     BEGIN TASKSCALAR       #
##############################
[TaskScalar]
VersionSize   = 32          # Version size (HVersion) in bits
SyncOnRestart =  3          # Number of restarts before wait to become safe
MLThreshold   = 8*$(nCPUs)  # Merge Last  Threshold Safe thread
MFThreshold   = $(nCPUs)    # Merge First Threshold Safe thread
IDP           = 'IntPred1'  # Interval Predictor
bsize         = 64          # Versioned cache line size

################################
# IDP: Interval Distribution Predictor (one per processor)
[IntPred1]
deviceType   = 'cache' 
IDPnChildMax = 4     # 4 default value, 0 means no prediction
size         = 32*8  # 32 entries
bSize        = 8
Assoc        = 32
ReplPolicy   = 'LRU'
numPorts     = 1
portOccp     = 1
